# 回溯有两份模板
## 对每一个元素进行取舍
如78.cpp里面写的一样
``` C++
vector<vector<int>> ans;
void traverse(vector<int> path, int idx, vector<int>& nums) {
    if (idx == nums.size()) {
        ans.push_back(path);
        return;
    }
    traverse(path, idx + 1, nums);  // 不选第idx个元素
    
    path.push_back(nums[idx]);
    traverse(path, idx + 1, nums);  // 选第idx个元素
}
```

## 使用循环处理
还是举78.cpp的例子,不过使用循环来实现
``` C++
void traverse(vector<int> path, int idx, vector<int>& nums) {
    if (idx == nums.size()) {
        ans.push_back(path);
        return;
    }
    for (int i = idx; i < nums.size(); i++) {
        path.push_back(nums[i]);
        traverse(path, i + 1, nums);
        path.pop_back();
    }
    traverse(path, nums.size(), nums);  // 这里需要继续递归一次,有的时候不需要,有的时候需要(因为边界情况)
}
```

使用循环处理回溯可以用一个全新的视角来看待:
- 一个traverse函数就是二叉树中的一个节点
- path是这个节点的状态
- 从这个节点需要衍生出很多子节点,这些子节点在循环中衍生出来
- 循环中调用traverse,就是进入子节点中递归处理

-----------------------------------------------
解释一下下列代码的作用
``` C++
for (int i = idx; i < nums.size(); i++) {
    path.push_back(nums[i]);        
    traverse(path, i + 1, nums);    // 子节点的状态为原来的path+nums[i],进入子节点递归
    path.pop_back();      // 子节点递归结束,回到父节点,则状态也需要回到原来的path
    // 之后处理下一个子节点
}
```
简而言之,在这个循环中做三件事: 
1. 得到子节点状态
2. 递归处理子节点
3. 回到父节点中,状态变为原来的,继续处理下一个子节点

## 小结
普适的情况是第二种情况,使用循环来处理.注意一些边界条件即可
回溯法就是一棵二叉树,画图可以很好的理解.